#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'open-uri'
require 'json'
require 'yaml'
require 'socket'
require 'pp'

config = YAML::load_file('nrql_exporter.conf')
unless config.has_key?("nr") && config["nr"].has_key?("api_key") && config["nr"].has_key?("account_id")
  STDERR.puts "Missing new relic configuration information" 
  exit 1
end
unless config.has_key?("queries") && !config["queries"].empty?
  STDERR.puts "No NRQL queries defined"
end
unless config.has_key?("exporter") && config["exporter"].has_key?("host") && config["exporter"].has_key?("port")
  STDERR.puts "No host and port defined"
  exit 1
end
unless config.has_key?("exporter") && config["exporter"].has_key?("verbose")
	config["exporter"]["verbose"] = false
end

server = TCPServer.new(config["exporter"]["host"], config["exporter"]["port"])

def do_query(config, query)
  uri = URI.parse("https://insights-api.newrelic.com/v1/accounts/#{config['nr']['account_id']}/query?nrql=#{URI::encode(query)}")
  STDERR.puts pp uri if config["exporter"]["verbose"]
  request = Net::HTTP::Get.new(uri)
  request["Accept"] = "application/json"
  request["User-Agent"] = "nrql_exporter"
  request["X-Query-Key"] = config['nr']['api_key']

  req_options = {
    use_ssl: uri.scheme == "https",
  }

  proxy_addr = config["exporter"].has_key?("proxy_addr") ? config["exporter"]["proxy_addr"] : nil
  proxy_port = config["exporter"].has_key?("proxy_port") ? config["exporter"]["proxy_port"] : nil

  response = Net::HTTP.start(uri.hostname, uri.port, proxy_addr, proxy_port, req_options) do |http|
    http.request(request)
  end

  r = JSON.parse(response.body)
  STDERR.puts pp r if config["exporter"]["verbose"]

  results = {}
  if r.has_key?("results") && !r["results"].empty?
    results = r["results"].first
  end
  return results
end

def metrics(config)
  results = {}
  config["queries"].each do |query|
    result = do_query(config, query["query"])
    if result.has_key?("count")
      results[query["name"]] = { "count" => result["count"] }
      results[query["name"]]["help"] = query["help"] if query.has_key?("help")
      results[query["name"]]["type"] = query["type"] if query.has_key?("type")
	end
  end

  response = ""
  results.each_key do |label|
  	data = results[label]
    help = data["help"]
    type = data["type"]
    count = data["count"]
    response += "\# HELP #{label} #{help}\n" if data.has_key?("help")
    response += "\# TYPE #{label} #{type}\n" if data.has_key?("type")
    response += "#{config['exporter']['prefix']}#{label} #{count}\n"
  end
  STDERR.puts pp response if config["exporter"]["verbose"]
  return response
end

requested = Time.now()
cached_response = ""
loop do
  begin
    socket = server.accept
    request = socket.gets
    STDERR.puts request if config["exporter"]["verbose"]
    if request.match("/metrics")
      if Time.now-requested > config["exporter"]["cache"].to_i || cached_response.empty?
        requested = Time.now
        response = metrics(config)
        cached_response = response
      else
        response = cached_response
      end
      socket.print "HTTP/1.1 200 OK\n" +
                 "Content-Type: text/plain\n" +
                 "Content-Length: #{response.bytesize}\n" +
                 "Connection: close\n"
      socket.print "\n"
      socket.print response
    else
      socket.print "HTTP/1.1 404 Not Found\n" +
                 "Content-Type: text/plain\n" +
                 "Connection: close\n"
      socket.print "\n"
    end
  rescue StandardError => e
    cached_response = ""
    begin
      socket.print "HTTP/1.1 500 Internal Server Error\n" +
                   "Content-Type: text/plain\n" +
                   "Connection: close\n"
      socket.print "\n"
      socket.print "Server Error\n"
    rescue StandardError => e
      # Captures client disconnect
    end
  end
  socket.close
end

